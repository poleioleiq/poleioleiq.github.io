<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[当然是线段树模板]]></title>
    <url>%2F2019%2F07%2F20%2F%E5%BD%93%E7%84%B6%E6%98%AF%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[1234567891011121314struct segt &#123; ll *a; ll SUM, MAX, MIN; struct Tree &#123; int l, r; ll sum, lz, max, min, set; void update(ll v) &#123; sum += v * (r - l + 1); lz += v; max += v; min += v; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169 void setval(ll v) &#123; sum = v * (r - l + 1); lz = 0; max = v; min = v; set = v; &#125; &#125; tree[N * 4]; void modify(ll *arr) &#123; a = arr; &#125; void pushup(int x) &#123; tree[x].sum = tree[2 * x].sum + tree[2 * x + 1].sum; tree[x].max = max(tree[2 * x].max, tree[2 * x + 1].max); tree[x].min = min(tree[2 * x].min, tree[2 * x + 1].min); &#125; void pushdown(int x) &#123; if (tree[x].set != -1) &#123; tree[2 * x].setval(tree[x].set); tree[2 * x + 1].setval(tree[x].set); tree[x].set = -1; &#125; if (tree[x].lz != 0) &#123; tree[2 * x].update(tree[x].lz); tree[2 * x + 1].update(tree[x].lz); tree[x].lz = 0; &#125; &#125; // 建树 void build(int x, int l, int r) &#123; tree[x].l = l; tree[x].r = r; tree[x].sum = tree[x].max = tree[x].min = tree[x].lz = 0; tree[x].set = -1; if (l == r) &#123; return; &#125; int mid = (l + r) / 2; build(2 * x, l, mid); build(2 * x + 1, mid + 1, r); pushup(x); &#125; // 将 l-r 范围的数都加上 c void update(int x, int l, int r, ll c) &#123; int L = tree[x].l, R = tree[x].r; int mid = (L + R) / 2; if ((l &lt;= L) &amp;&amp; (r &gt;= R)) &#123; tree[x].update(c); return; &#125; pushdown(x); if (l &lt;= mid) update(2 * x, l, r, c); if (r &gt; mid) update(2 * x + 1, l, r, c); pushup(x); &#125; // 将 l-r 范围的数变成 c， 如果 set 为 -1 表示没有被赋值过 void setval(int x, int l, int r, ll c) &#123; int L = tree[x].l, R = tree[x].r; int mid = (L + R) / 2; if ((l &lt;= L) &amp;&amp; (r &gt;= R)) &#123; tree[x].setval(c); return; &#125; pushdown(x); if (l &lt;= mid) setval(2 * x, l, r, c); if (r &gt; mid) setval(2 * x + 1, l, r, c); pushup(x); &#125; // 查询区间和 ll querySUM(int x, int l, int r) &#123; int L = tree[x].l, R = tree[x].r; int mid = (L + R) / 2; ll res = 0; if ((l &lt;= L) &amp;&amp; (r &gt;= R)) &#123; // 要更新区间包括了该区间 return tree[x].sum; &#125; pushdown(x); if (l &lt;= mid) res += querySUM(2 * x, l, r); if (r &gt; mid) res += querySUM(2 * x + 1, l, r); return res; &#125; // 查询区间最大值 ll queryMAX(int x, int l, int r) &#123; int L = tree[x].l, R = tree[x].r; int mid = (L + R) / 2; ll res = -maxx; if ((l &lt;= L) &amp;&amp; (r &gt;= R)) &#123; // 要更新区间包括了该区间 return tree[x].max; &#125; pushdown(x); if (l &lt;= mid) res = max(res, queryMAX(2 * x, l, r)); if (r &gt; mid) res = max(res, queryMAX(2 * x + 1, l, r)); return res; &#125; // 查询区间最小值 ll queryMIN(int x, int l, int r) &#123; int L = tree[x].l, R = tree[x].r; int mid = (L + R) / 2; ll res = maxx; if ((l &lt;= L) &amp;&amp; (r &gt;= R)) &#123; // 要更新区间包括了该区间 return tree[x].min; &#125; pushdown(x); if (l &lt;= mid) res = min(res, queryMIN(2 * x, l, r)); if (r &gt; mid) res = min(res, queryMIN(2 * x + 1, l, r)); return res; &#125; // 一次性查询区间 SUM，MAX，MIN void query(int x, int l, int r) &#123; int L = tree[x].l, R = tree[x].r; int mid = (L + R) / 2; if ((l &lt;= L) &amp;&amp; (r &gt;= R)) &#123; // 要更新区间包括了该区间 SUM += tree[x].sum; MAX = max(MAX, tree[x].max); MIN = min(MIN, tree[x].min); return; &#125; pushdown(x); if (l &lt;= mid) query(2 * x, l, r); if (r &gt; mid) query(2 * x + 1, l, r); &#125;&#125; tree;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo部署blog]]></title>
    <url>%2F2019%2F07%2F20%2F%E6%97%A5%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[部署了hexo+github的博客 参考了https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html 搭建基于github的个人blog参考了https://www.jianshu.com/p/9f0e90cc32c2 对网站进行优化]]></content>
      <tags>
        <tag>日常</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[还是畅通工程]]></title>
    <url>%2F2019%2F07%2F20%2F%E8%BF%98%E6%98%AF%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[这还是一道基本的并查集模板题 ，init()初始化 ,find()找父亲 ，join()按照rank数组的高度合并 低的到高的上 ，大功告成啦。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;climits&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;map&gt;#define maxx 0x3f3f3f3f#define ll long long#define FAST_IO std::ios::sync_with_stdio(false), std::cin.tie(0), std::cout.tie(0)#define lson l, m, rt &lt;&lt; 1#define rson m + 1, r, rt &lt;&lt; 1 | 1using namespace std;const int maxn = 1e4 + 5;int ran[maxn];int pre[maxn];int n, m;void init()&#123; for (int i = 1; i &lt;= n; i++) &#123; pre[i] = i; ran[i] = 1; &#125;&#125;int find(int x)&#123; if (x == pre[x]) return x; return pre[x] = find(pre[x]);&#125;void join(int x, int y)&#123; int fx = find(x); int fy = find(y); if (fx == fy) return; if (ran[x] &lt; ran[y]) pre[fx] = fy; else &#123; pre[fy] = fx; if (ran[fx] == ran[fy]) ran[fx]++; &#125;&#125;int main()&#123; FAST_IO; while (cin &gt;&gt; n, n) &#123; cin &gt;&gt; m; init(); int a, b; while (m--) &#123; cin &gt;&gt; a &gt;&gt; b; join(a, b); &#125; int ans = 0; for (int i = 1; i &lt;= n; i++) &#123; if (pre[i] == i) ans++; &#125; cout &lt;&lt; ans - 1 &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
</search>
