<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java中Map的 entrySet() 详解以及用法(四种遍历map的方式)]]></title>
    <url>%2F2019%2F10%2F16%2FJava%E4%B8%ADMap%E7%9A%84-entrySet-%E8%AF%A6%E8%A7%A3%E4%BB%A5%E5%8F%8A%E7%94%A8%E6%B3%95-%E5%9B%9B%E7%A7%8D%E9%81%8D%E5%8E%86map%E7%9A%84%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Java中Map的 entrySet() 详解以及用法(四种遍历map的方式) Entry由于Map中存放的元素均为键值对，故每一个键值对必然存在一个映射关系。Map中采用Entry内部类来表示一个映射项，映射项包含Key和Value (我们总说键值对键值对, 每一个键值对也就是一个Entry)Map.Entry里面包含getKey()和getValue()方法 1234567Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; it=map.entrySet().iterator(); while(it.hasNext()) &#123; Map.Entry&lt;Integer,Integer&gt; entry=it.next(); int key=entry.getKey(); int value=entry.getValue(); System.out.println(key+" "+value); &#125; entrySetentrySet是 java中 键-值 对的集合，Set里面的类型是Map.Entry，一般可以通过map.entrySet()得到。 entrySet实现了Set接口，里面存放的是键值对。一个K对应一个V。用来遍历map的一种方法。 1234567Set&lt;Map.Entry&lt;String, String&gt;&gt; entryseSet=map.entrySet(); for (Map.Entry&lt;String, String&gt; entry:entryseSet) &#123; System.out.println(entry.getKey()+","+entry.getValue()); &#125; 即通过getKey（）得到K，getValue得到V。 keySet还有一种是keySet, keySet是键的集合，Set里面的类型即key的类型 1234567Set&lt;String&gt; set = map.keySet(); for (String s:set) &#123; System.out.println(s+","+map.get(s)); &#125; 四种遍历Map方式: 123456789101112131415161718192021222324252627282930313233public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put("1", "value1"); map.put("2", "value2"); map.put("3", "value3"); //第一种：普遍使用，二次取值 System.out.println("通过Map.keySet遍历key和value："); for (String key : map.keySet()) &#123; System.out.println("key= "+ key + " and value= " + map.get(key)); &#125; //第二种 System.out.println("通过Map.entrySet使用iterator遍历key和value："); Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator(); while (it.hasNext()) &#123; Map.Entry&lt;String, String&gt; entry = it.next(); System.out.println("key= " + entry.getKey() + " and value= " + entry.getValue()); &#125; //第三种：推荐，尤其是容量大时 System.out.println("通过Map.entrySet遍历key和value"); for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123; System.out.println("key= " + entry.getKey() + " and value= " + entry.getValue()); &#125; //**第四种** System.out.println("通过Map.values()遍历所有的value，但不能遍历key"); for (String v : map.values()) &#123; System.out.println("value= " + v); &#125; &#125;]]></content>
      <tags>
        <tag>java</tag>
        <tag>HashMap</tag>
        <tag>遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[元素除重的方法比较]]></title>
    <url>%2F2019%2F10%2F16%2F%E5%85%83%E7%B4%A0%E9%99%A4%E9%87%8D%E7%9A%84%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[如题：有List list1和List list2,两个集合各有上万个元素，怎样取出两个集合中不同的元素? 方法1：遍历两个集合： 123456789101112131415161718192021222324252627282930313233343536373839package com.czp.test; import java.util.ArrayList; import java.util.List; public class TestList &#123; public static void main(String[] args) &#123; List&lt;String&gt; list1 = new ArrayList&lt;String&gt;(); List&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); for (int i = 0; i &lt; 10000; i++) &#123; list1.add("test"+i); list2.add("test"+i*2); &#125; getDiffrent(list1,list2); //输出：total times 2566454675 &#125; /** * 获取两个List的不同元素 * @param list1 * @param list2 * @return */ private static List&lt;String&gt; getDiffrent(List&lt;String&gt; list1, List&lt;String&gt; list2) &#123; long st = System.nanoTime(); List&lt;String&gt; diff = new ArrayList&lt;String&gt;(); for(String str:list1) &#123; if(!list2.contains(str)) &#123; diff.add(str); &#125; &#125; System.out.println("total times "+(System.nanoTime()-st)); return diff; &#125; &#125; 千万不要采用这种方法，总共要循环的次数是两个List的size相乘的积，从输出看耗时也是比较长的，那么我们有没有其他的方法呢？当然有.方法2：采用List提供的retainAll（）方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.czp.test; import java.util.ArrayList; import java.util.List; public class TestList &#123; public static void main(String[] args) &#123; List&lt;String&gt; list1 = new ArrayList&lt;String&gt;(); List&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); for (int i = 0; i &lt; 10000; i++) &#123; list1.add("test"+i); list2.add("test"+i*2); &#125; getDiffrent(list1,list2); //输出：total times 2566454675 getDiffrent2(list1,list2); //输出：getDiffrent2 total times 2787800964 &#125; /** * 获取连个List的不同元素 * @param list1 * @param list2 * @return */ private static List&lt;String&gt; getDiffrent2(List&lt;String&gt; list1, List&lt;String&gt; list2) &#123; long st = System.nanoTime(); list1.retainAll(list2); System.out.println("getDiffrent2 total times "+(System.nanoTime()-st)); return list1; &#125; /** * 获取两个List的不同元素 * @param list1 * @param list2 * @return */ private static List&lt;String&gt; getDiffrent(List&lt;String&gt; list1, List&lt;String&gt; list2) &#123; long st = System.nanoTime(); List&lt;String&gt; diff = new ArrayList&lt;String&gt;(); for(String str:list1) &#123; if(!list2.contains(str)) &#123; diff.add(str); &#125; &#125; System.out.println("getDiffrent total times "+(System.nanoTime()-st)); return diff; &#125; &#125; 很遗憾，这种方式虽然只要几行代码就搞定，但是这个却更耗时，查看retainAll（）的源码: 1234567891011 public boolean retainAll(Collection&lt;?&gt; c) &#123; boolean modified = false; Iterator&lt;E&gt; e = iterator(); while (e.hasNext()) &#123; if (!c.contains(e.next())) &#123; e.remove(); modified = true; &#125; &#125; return modified; &#125; text无需解释这个耗时是必然的，那么我们还有没有更好的办法呢？仔细分析以上两个方法中我都做了mXn次循环，其实完全没有必要循环这么多次，我们的需求是找出两个List中的不同元素,那么我可以这样考虑：用一个map存放lsit的所有元素，其中的key为lsit1的各个元素，value为该元素出现的次数,接着把list2的所有元素也放到map里，如果已经存在则value加1，最后我们只要取出map里value为1的元素即可，这样我们只需循环m+n次，大大减少了循环的次数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package com.czp.test; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; public class TestList &#123; public static void main(String[] args) &#123; List&lt;String&gt; list1 = new ArrayList&lt;String&gt;(); List&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); for (int i = 0; i &lt; 10000; i++) &#123; list1.add("test"+i); list2.add("test"+i*2); &#125; getDiffrent(list1,list2); //输出：total times 2566454675 getDiffrent2(list1,list2); //输出：getDiffrent2 total times 2787800964 getDiffrent3(list1,list2); //输出：getDiffrent3 total times 61763995 &#125; /** * 获取两个List的不同元素 * @param list1 * @param list2 * @return */ private static List&lt;String&gt; getDiffrent3(List&lt;String&gt; list1, List&lt;String&gt; list2) &#123; long st = System.nanoTime(); Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;(list1.size()+list2.size()); List&lt;String&gt; diff = new ArrayList&lt;String&gt;(); for (String string : list1) &#123; map.put(string, 1); &#125; for (String string : list2) &#123; Integer cc = map.get(string); if(cc!=null) &#123; map.put(string, ++cc); continue; &#125; map.put(string, 1); &#125; for(Map.Entry&lt;String, Integer&gt; entry:map.entrySet()) &#123; if(entry.getValue()==1) &#123; diff.add(entry.getKey()); &#125; &#125; System.out.println("getDiffrent3 total times "+(System.nanoTime()-st)); return list1; &#125; /** * 获取两个List的不同元素 * @param list1 * @param list2 * @return */ private static List&lt;String&gt; getDiffrent2(List&lt;String&gt; list1, List&lt;String&gt; list2) &#123; long st = System.nanoTime(); list1.retainAll(list2); System.out.println("getDiffrent2 total times "+(System.nanoTime()-st)); return list1; &#125; /** * 获取两个List的不同元素 * @param list1 * @param list2 * @return */ private static List&lt;String&gt; getDiffrent(List&lt;String&gt; list1, List&lt;String&gt; list2) &#123; long st = System.nanoTime(); List&lt;String&gt; diff = new ArrayList&lt;String&gt;(); for(String str:list1) &#123; if(!list2.contains(str)) &#123; diff.add(str); &#125; &#125; System.out.println("getDiffrent total times "+(System.nanoTime()-st)); return diff; &#125; &#125; 显然，这种方法大大减少耗时，是方法1的1/4，是方法2的1/40，这个性能的提升时相当可观的，但是，这不是最佳的解决方法，观察方法3我们只是随机取了一个list作为首次添加的标准，这样一旦我们的list2比list1的size大，则我们第二次put时的if判断也会耗时，做如下改进： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131package com.czp.test; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; public class TestList &#123; public static void main(String[] args) &#123; List&lt;String&gt; list1 = new ArrayList&lt;String&gt;(); List&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); for (int i = 0; i &lt; 10000; i++) &#123; list1.add("test"+i); list2.add("test"+i*2); &#125; getDiffrent(list1,list2); getDiffrent2(list1,list2); getDiffrent3(list1,list2); getDiffrent4(list1,list2); // getDiffrent total times 2789492240 // getDiffrent2 total times 3324502695 // getDiffrent3 total times 24710682 // getDiffrent4 total times 15627685 &#125; /** * 获取两个List的不同元素 * @param list1 * @param list2 * @return */ private static List&lt;String&gt; getDiffrent4(List&lt;String&gt; list1, List&lt;String&gt; list2) &#123; long st = System.nanoTime(); Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;(list1.size()+list2.size()); List&lt;String&gt; diff = new ArrayList&lt;String&gt;(); List&lt;String&gt; maxList = list1; List&lt;String&gt; minList = list2; if(list2.size()&gt;list1.size()) &#123; maxList = list2; minList = list1; &#125; for (String string : maxList) &#123; map.put(string, 1); &#125; for (String string : minList) &#123; Integer cc = map.get(string); if(cc!=null) &#123; map.put(string, ++cc); continue; &#125; map.put(string, 1); &#125; for(Map.Entry&lt;String, Integer&gt; entry:map.entrySet()) &#123; if(entry.getValue()==1) &#123; diff.add(entry.getKey()); &#125; &#125; System.out.println("getDiffrent4 total times "+(System.nanoTime()-st)); return diff; &#125; /** * 获取两个List的不同元素 * @param list1 * @param list2 * @return */ private static List&lt;String&gt; getDiffrent3(List&lt;String&gt; list1, List&lt;String&gt; list2) &#123; long st = System.nanoTime(); Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;(list1.size()+list2.size()); List&lt;String&gt; diff = new ArrayList&lt;String&gt;(); for (String string : list1) &#123; map.put(string, 1); &#125; for (String string : list2) &#123; Integer cc = map.get(string); if(cc!=null) &#123; map.put(string, ++cc); continue; &#125; map.put(string, 1); &#125; for(Map.Entry&lt;String, Integer&gt; entry:map.entrySet()) &#123; if(entry.getValue()==1) &#123; diff.add(entry.getKey()); &#125; &#125; System.out.println("getDiffrent3 total times "+(System.nanoTime()-st)); return diff; &#125; /** * 获取连个List的不同元素 * @param list1 * @param list2 * @return */ private static List&lt;String&gt; getDiffrent2(List&lt;String&gt; list1, List&lt;String&gt; list2) &#123; long st = System.nanoTime(); list1.retainAll(list2); System.out.println("getDiffrent2 total times "+(System.nanoTime()-st)); return list1; &#125; /** * 获取两个List的不同元素 * @param list1 * @param list2 * @return */ private static List&lt;String&gt; getDiffrent(List&lt;String&gt; list1, List&lt;String&gt; list2) &#123; long st = System.nanoTime(); List&lt;String&gt; diff = new ArrayList&lt;String&gt;(); for(String str:list1) &#123; if(!list2.contains(str)) &#123; diff.add(str); &#125; &#125; System.out.println("getDiffrent total times "+(System.nanoTime()-st)); return diff; &#125; &#125;]]></content>
      <tags>
        <tag>java</tag>
        <tag>HashMap</tag>
        <tag>javaCollection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中HashMap.put()方法]]></title>
    <url>%2F2019%2F10%2F16%2Fjava%E4%B8%ADHashMap-put-%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[java中HashMap.put()方法 HashMap的java.util.HashMap.put()方法用于将映射插入到映射中。这意味着我们可以将特定键及其映射的值插入到特定映射中。如果传递现有密钥，则先前的值将被新值替换。如果传递了一对新对，那么该对将作为整体插入。 句法： Hash_Map.put(key, value)参数：该方法有两个参数，都是HashMap的Object类型。 key：这是指需要插入Map进行映射s的关键元素。 value：这是指上面的键映射到的值。返回值：如果传递现有密钥，则返回先前的值。如果传递了一对新对，则返回NULL。 下面的程序用于说明java.util.HashMap.put()的工作方法HashMap.put()程序1：传递现有密钥时。 123456789101112131415161718192021222324252627282930// Java code to illustrate the put() methodimport java.util.*; public class Hash_Map_Demo &#123; public static void main(String[] args) &#123; // Creating an empty HashMap HashMap&lt;Integer, String&gt; hash_map = new HashMap&lt;Integer, String&gt;(); // Mapping string values to int keys hash_map.put(10, "Geeks"); hash_map.put(15, "4"); hash_map.put(20, "Geeks"); hash_map.put(25, "Welcomes"); hash_map.put(30, "You"); // Displaying the HashMap System.out.println("Initial Mappings are: " + hash_map); // Inserting existing key along with new value String returned_value = (String)hash_map.put(20, "All"); // Verifying the returned value System.out.println("Returned value is: " + returned_value); // Displayin the new map System.out.println("New map is: " + hash_map); &#125;&#125; 输出： 123Initial Mappings are: &#123;20=Geeks, 25=Welcomes, 10=Geeks, 30=You, 15=4&#125;Returned value is: GeeksNew map is: &#123;20=All, 25=Welcomes, 10=Geeks, 30=You, 15=4&#125; HashMap.put()程序2：传递新密钥时。 123456789101112131415161718192021222324252627282930// Java code to illustrate the put() methodimport java.util.*; public class Hash_Map_Demo &#123; public static void main(String[] args) &#123; // Creating an empty HashMap HashMap&lt;Integer, String&gt; hash_map = new HashMap&lt;Integer, String&gt;(); // Mapping string values to int keys hash_map.put(10, "Geeks"); hash_map.put(15, "4"); hash_map.put(20, "Geeks"); hash_map.put(25, "Welcomes"); hash_map.put(30, "You"); // Displaying the HashMap System.out.println("Initial Mappings are: " + hash_map); // Inserting existing key along with new value String returned_value = (String)hash_map.put(50, "All"); // Verifying the returned value System.out.println("Returned value is: " + returned_value); // Displayin the new map System.out.println("New map is: " + hash_map); &#125;&#125; 输出： 123Initial Mappings are: &#123;20=Geeks, 25=Welcomes, 10=Geeks, 30=You, 15=4&#125;Returned value is: nullNew map is: &#123;50=All, 20=Geeks, 25=Welcomes, 10=Geeks, 30=You, 15=4&#125; 注意：对于具有不同数据类型的变体和组合的任何类型的映射，都可以执行相同的操作。]]></content>
      <tags>
        <tag>java</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tensorflow(01)]]></title>
    <url>%2F2019%2F08%2F14%2Ftensorflow%2F</url>
    <content type="text"><![CDATA[写的第一个tensorflow玩具,感觉很有趣，就贴一下代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344# -*- coding: utf-8 -*-"""Created on Wed Aug 14 08:59:44 2019@author: mwt"""import tensorflow as tfimport numpy as np#create datax_data=np.random.rand(100).astype(np.float32) #x集合y_data=x_data*0.1+0.3 #要拟合的权和偏置#create tensorflow structure start#Weights=tf.Variable(tf.random_uniform([1],-1.0,1.0)) #一个一维的范围为-1---1的全职biases=tf.Variable(tf.zeros([1])) #偏差一开始为0y=Weights*x_data+biasesloss=tf.reduce_mean(tf.square(y-y_data))optimizer = tf.train.GradientDescentOptimizer(0.5)train=optimizer.minimize(loss)#版本1.2一下就用tf.initializa_all_variable ()#初始化sess=tf.Session()if int((tf.__version__).split('.')[1]) &lt; 12 and int((tf.__version__).split('.')[0]) &lt; 1: init = tf.initialize_all_variables()else: init = tf.global_variables_initializer()#endlsess.run(init) #激活initfor step in range(2001): sess.run(train) if step % 20==0: print(step,sess.run(Weights),sess.run(biases)) 以下是循环500次得出的biases和Weights]]></content>
      <tags>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一次win10下安装tensorflow的踩坑经历]]></title>
    <url>%2F2019%2F08%2F12%2F%E4%B8%80%E6%AC%A1win10%E4%B8%8B%E5%AE%89%E8%A3%85tensorflow%E7%9A%84%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86%2F</url>
    <content type="text"><![CDATA[一次悲惨的tensorflow踩坑经历 废话少说:本人配置是1660-ti i7-9750hq 需要 anaconda3 cuda9.0 以及cudnn7.0 需要另外版本的可以自行百度。cuda9.0以及cudnn7.0百度云链接: https://pan.baidu.com/s/1qdpFUbHgKHnHoJBqVFjP3Q 提取码: 6nsranaconda由于国外源速度太捉急，推荐使用清华镜像。可以在promte中输入以下更换成清华镜像。 123456conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forgeconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/# 设置搜索时显示通道地址conda config --set show_channel_urls yes 1.因为tensorflow只支持python3.5-3.6,所以anaconda 安装的环境代码为 12conda create --name tensorflow_gpu python=3.5conda create --name tensorflow_gpu python=3.6 2.之后激活环境 1activate tensorflow_gpu 你打开navigter界面会发现存在基本的环境就已经配好了3.之后安装tensorflow-gpu的组件，顺便安装一个keras的gpu版本,keras也是一个神经网络库 12conda install tensorflow-gpuconda install keras-gpu 3.1以上两行存在疑问，虽然anaconda安装好tensorflow-gpu1.10就已经自带cuda8.0和cudnn6.0,但是我发现经过该尝试后存在环境变量里没有相应配置，导致不能import tensorflow。笔者在多次尝试后还是选择了pip安装，代码如下 12pip install tensorflow-gpu==1.10 -i https://pypi.tuna.tsinghua.edu.cn/simple #在包名后面加==和版本号可指定版本安装pip install tensorflow-gpu -i https://pypi.tuna.tsinghua.edu.cn/simple #默认安装最新版本 笔者选择了1.6.0版本，这里不推荐安装最新版本的tensorflow，可能会存在兼容问题。运行完是这样的 import一下，此时没有安装cuda9.0，出现以下错误 4.之后配置cuda9.0,选择相应的版本。笔者选择安装本地版，在这个墙比山高的地方，网络版速度实在捉急进度条读完就进入安装界面，(如果你的驱动版本高于cuda9.0，它会提示识别不了，但是不用管他，装就完事了)之后选择精简版安装(自定义安装，因为我们只需要cuda) 5.安装完解压cudnn。将解压出来的三个文件夹放到v9文件夹下惯例，添加环境变量 保存退出。再重新进入anaconda promote，运行gpu环境 一般来说到这里就完结了，一下讲一下笔者遇到的玄学时刻 001.numpy版本问题，一开始numpy版本为1.16，出现了numpy 版本不兼容tensorflow的问题 1ImportError: Something is wrong with the numpy installation. While importing we detected an older version of numpy in ['C:\\Users\\Administrator\\Anaconda3\\lib\\site-packages\\numpy']. One method of fixing this is to repeatedly uninstall numpy until none is found, then reinstall this version. 随后笔者更改numpy1.13，代码以下卸载numpy包 1pip uninstall numpy 安装版本为1.13numpy 1pip install numpy=1.13 笔者这里终于成功了，教训深刻。。。可以看出cuda成功运行 这里附上hello world 代码嘻嘻 12345import tensorflow as tfhello = tf.constant("Hello!TensorFlow")sess = tf.Session()print(sess.run(hello)) 002.windows版本tensorflow的兼容性参考 ps.实际上，2017.12的时候，tensorflow 1.4及以下的不支持cuda9.0，且tensorflow1.0版本以上是不支持cuda8.0以下的.tensorflow -gpu1.5以后不支持使用CUDA8.0.cuda8.0对应的cuDNN必须是6.0版的。]]></content>
      <tags>
        <tag>tensorflow</tag>
        <tag>神经网络</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sekiro之河原田直盛(1)]]></title>
    <url>%2F2019%2F08%2F04%2Fsekiro%2F</url>
    <content type="text"><![CDATA[那么今天打的怪是何方妖孽呢？武士大将河原田直盛，嗯，就是这个看起来挺牛逼的名字，其实说实话是挺牛逼的（你把我逼死了好几十次。。。orz我真的服了）。就是这个小崽子 本着莽就完事的宗旨，上来就被土肥原三刀劈翻在地，出现了上来就秒死的尴尬状况，我当即按下RB，半条命再战，结果也不用猜了 随后n把我逐渐学会了关于死字的书法。我吐了。 欸这就很难受了，随即再战，两段钩锁飞到面前，B键猛冲，就是要砍脸，仙法–X键狂点之术！！很搞笑我被土肥原踹了下去，复活回来就发现土肥原被困在一个小角落 当我熟练使用gay洛的拜年剑法的时候，惨了，土肥原40米大刀一招扫地龙已把我收了。。 随即又是n次 终于我发现可以忍杀掉一条命的时候，又tm的最悲惨的是，人跳下去了，那个红点却不见了。完了，又是被砍死。 途中还有几次忍杀成功的，两刀砍死。。。 终于这回轻装上阵，拿起刀就是往脸上招呼，虽然没有一下子忍杀掉，但土肥原招架不住我犀利的刀法，一条命get。我随即狂按B键迅速拉开身位，熟练地拿起小葫芦灌了一口药。看到血量回升的感觉真的舒服。废话不多说，敌进我退敌疲我打，关键时候乱刀招呼，直接忍杀！ 炫，疯狂地炫]]></content>
      <tags>
        <tag>游戏</tag>
        <tag>之狼</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[当然是线段树模板]]></title>
    <url>%2F2019%2F07%2F20%2F%E5%BD%93%E7%84%B6%E6%98%AF%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[1234567891011121314struct segt &#123; ll *a; ll SUM, MAX, MIN; struct Tree &#123; int l, r; ll sum, lz, max, min, set; void update(ll v) &#123; sum += v * (r - l + 1); lz += v; max += v; min += v; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169 void setval(ll v) &#123; sum = v * (r - l + 1); lz = 0; max = v; min = v; set = v; &#125; &#125; tree[N * 4]; void modify(ll *arr) &#123; a = arr; &#125; void pushup(int x) &#123; tree[x].sum = tree[2 * x].sum + tree[2 * x + 1].sum; tree[x].max = max(tree[2 * x].max, tree[2 * x + 1].max); tree[x].min = min(tree[2 * x].min, tree[2 * x + 1].min); &#125; void pushdown(int x) &#123; if (tree[x].set != -1) &#123; tree[2 * x].setval(tree[x].set); tree[2 * x + 1].setval(tree[x].set); tree[x].set = -1; &#125; if (tree[x].lz != 0) &#123; tree[2 * x].update(tree[x].lz); tree[2 * x + 1].update(tree[x].lz); tree[x].lz = 0; &#125; &#125; // 建树 void build(int x, int l, int r) &#123; tree[x].l = l; tree[x].r = r; tree[x].sum = tree[x].max = tree[x].min = tree[x].lz = 0; tree[x].set = -1; if (l == r) &#123; return; &#125; int mid = (l + r) / 2; build(2 * x, l, mid); build(2 * x + 1, mid + 1, r); pushup(x); &#125; // 将 l-r 范围的数都加上 c void update(int x, int l, int r, ll c) &#123; int L = tree[x].l, R = tree[x].r; int mid = (L + R) / 2; if ((l &lt;= L) &amp;&amp; (r &gt;= R)) &#123; tree[x].update(c); return; &#125; pushdown(x); if (l &lt;= mid) update(2 * x, l, r, c); if (r &gt; mid) update(2 * x + 1, l, r, c); pushup(x); &#125; // 将 l-r 范围的数变成 c， 如果 set 为 -1 表示没有被赋值过 void setval(int x, int l, int r, ll c) &#123; int L = tree[x].l, R = tree[x].r; int mid = (L + R) / 2; if ((l &lt;= L) &amp;&amp; (r &gt;= R)) &#123; tree[x].setval(c); return; &#125; pushdown(x); if (l &lt;= mid) setval(2 * x, l, r, c); if (r &gt; mid) setval(2 * x + 1, l, r, c); pushup(x); &#125; // 查询区间和 ll querySUM(int x, int l, int r) &#123; int L = tree[x].l, R = tree[x].r; int mid = (L + R) / 2; ll res = 0; if ((l &lt;= L) &amp;&amp; (r &gt;= R)) &#123; // 要更新区间包括了该区间 return tree[x].sum; &#125; pushdown(x); if (l &lt;= mid) res += querySUM(2 * x, l, r); if (r &gt; mid) res += querySUM(2 * x + 1, l, r); return res; &#125; // 查询区间最大值 ll queryMAX(int x, int l, int r) &#123; int L = tree[x].l, R = tree[x].r; int mid = (L + R) / 2; ll res = -maxx; if ((l &lt;= L) &amp;&amp; (r &gt;= R)) &#123; // 要更新区间包括了该区间 return tree[x].max; &#125; pushdown(x); if (l &lt;= mid) res = max(res, queryMAX(2 * x, l, r)); if (r &gt; mid) res = max(res, queryMAX(2 * x + 1, l, r)); return res; &#125; // 查询区间最小值 ll queryMIN(int x, int l, int r) &#123; int L = tree[x].l, R = tree[x].r; int mid = (L + R) / 2; ll res = maxx; if ((l &lt;= L) &amp;&amp; (r &gt;= R)) &#123; // 要更新区间包括了该区间 return tree[x].min; &#125; pushdown(x); if (l &lt;= mid) res = min(res, queryMIN(2 * x, l, r)); if (r &gt; mid) res = min(res, queryMIN(2 * x + 1, l, r)); return res; &#125; // 一次性查询区间 SUM，MAX，MIN void query(int x, int l, int r) &#123; int L = tree[x].l, R = tree[x].r; int mid = (L + R) / 2; if ((l &lt;= L) &amp;&amp; (r &gt;= R)) &#123; // 要更新区间包括了该区间 SUM += tree[x].sum; MAX = max(MAX, tree[x].max); MIN = min(MIN, tree[x].min); return; &#125; pushdown(x); if (l &lt;= mid) query(2 * x, l, r); if (r &gt; mid) query(2 * x + 1, l, r); &#125;&#125; tree;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo部署blog]]></title>
    <url>%2F2019%2F07%2F20%2F%E6%97%A5%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[部署了hexo+github的博客 参考了https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html 搭建基于github的个人blog参考了https://www.jianshu.com/p/9f0e90cc32c2 对网站进行优化]]></content>
      <tags>
        <tag>技术</tag>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[还是畅通工程]]></title>
    <url>%2F2019%2F07%2F20%2F%E8%BF%98%E6%98%AF%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[这还是一道基本的并查集模板题 ，init()初始化 ,find()找父亲 ，join()按照rank数组的高度合并 低的到高的上 ，大功告成啦。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;climits&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;map&gt;#define maxx 0x3f3f3f3f#define ll long long#define FAST_IO std::ios::sync_with_stdio(false), std::cin.tie(0), std::cout.tie(0)#define lson l, m, rt &lt;&lt; 1#define rson m + 1, r, rt &lt;&lt; 1 | 1using namespace std;const int maxn = 1e4 + 5;int ran[maxn];int pre[maxn];int n, m;void init()&#123; for (int i = 1; i &lt;= n; i++) &#123; pre[i] = i; ran[i] = 1; &#125;&#125;int find(int x)&#123; if (x == pre[x]) return x; return pre[x] = find(pre[x]);&#125;void join(int x, int y)&#123; int fx = find(x); int fy = find(y); if (fx == fy) return; if (ran[x] &lt; ran[y]) pre[fx] = fy; else &#123; pre[fy] = fx; if (ran[fx] == ran[fy]) ran[fx]++; &#125;&#125;int main()&#123; FAST_IO; while (cin &gt;&gt; n, n) &#123; cin &gt;&gt; m; init(); int a, b; while (m--) &#123; cin &gt;&gt; a &gt;&gt; b; join(a, b); &#125; int ans = 0; for (int i = 1; i &lt;= n; i++) &#123; if (pre[i] == i) ans++; &#125; cout &lt;&lt; ans - 1 &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
</search>
