<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[tensorflow(01)]]></title>
    <url>%2F2019%2F08%2F14%2Ftensorflow%2F</url>
    <content type="text"><![CDATA[写的第一个tensorflow玩具,感觉很有趣，就贴一下代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344# -*- coding: utf-8 -*-"""Created on Wed Aug 14 08:59:44 2019@author: mwt"""import tensorflow as tfimport numpy as np#create datax_data=np.random.rand(100).astype(np.float32) #x集合y_data=x_data*0.1+0.3 #要拟合的权和偏置#create tensorflow structure start#Weights=tf.Variable(tf.random_uniform([1],-1.0,1.0)) #一个一维的范围为-1---1的全职biases=tf.Variable(tf.zeros([1])) #偏差一开始为0y=Weights*x_data+biasesloss=tf.reduce_mean(tf.square(y-y_data))optimizer = tf.train.GradientDescentOptimizer(0.5)train=optimizer.minimize(loss)#版本1.2一下就用tf.initializa_all_variable ()#初始化sess=tf.Session()if int((tf.__version__).split('.')[1]) &lt; 12 and int((tf.__version__).split('.')[0]) &lt; 1: init = tf.initialize_all_variables()else: init = tf.global_variables_initializer()#endlsess.run(init) #激活initfor step in range(2001): sess.run(train) if step % 20==0: print(step,sess.run(Weights),sess.run(biases)) 以下是循环500次得出的biases和Weights]]></content>
      <tags>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一次win10下安装tensorflow的踩坑经历]]></title>
    <url>%2F2019%2F08%2F12%2F%E4%B8%80%E6%AC%A1win10%E4%B8%8B%E5%AE%89%E8%A3%85tensorflow%E7%9A%84%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86%2F</url>
    <content type="text"><![CDATA[一次悲惨的tensorflow踩坑经历 废话少说:本人配置是1660-ti i7-9750hq 需要 anaconda3 cuda9.0 以及cudnn7.0 需要另外版本的可以自行百度。cuda9.0以及cudnn7.0百度云链接: https://pan.baidu.com/s/1qdpFUbHgKHnHoJBqVFjP3Q 提取码: 6nsranaconda由于国外源速度太捉急，推荐使用清华镜像。可以在promte中输入以下更换成清华镜像。 123456conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forgeconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/# 设置搜索时显示通道地址conda config --set show_channel_urls yes 1.因为tensorflow只支持python3.5-3.6,所以anaconda 安装的环境代码为 12conda create --name tensorflow_gpu python=3.5conda create --name tensorflow_gpu python=3.6 2.之后激活环境 1activate tensorflow_gpu 你打开navigter界面会发现存在基本的环境就已经配好了3.之后安装tensorflow-gpu的组件，顺便安装一个keras的gpu版本,keras也是一个神经网络库 12conda install tensorflow-gpuconda install keras-gpu 3.1以上两行存在疑问，虽然anaconda安装好tensorflow-gpu1.10就已经自带cuda8.0和cudnn6.0,但是我发现经过该尝试后存在环境变量里没有相应配置，导致不能import tensorflow。笔者在多次尝试后还是选择了pip安装，代码如下 12pip install tensorflow-gpu==1.10 -i https://pypi.tuna.tsinghua.edu.cn/simple #在包名后面加==和版本号可指定版本安装pip install tensorflow-gpu -i https://pypi.tuna.tsinghua.edu.cn/simple #默认安装最新版本 笔者选择了1.6.0版本，这里不推荐安装最新版本的tensorflow，可能会存在兼容问题。运行完是这样的 import一下，此时没有安装cuda9.0，出现以下错误 4.之后配置cuda9.0,选择相应的版本。笔者选择安装本地版，在这个墙比山高的地方，网络版速度实在捉急进度条读完就进入安装界面，(如果你的驱动版本高于cuda9.0，它会提示识别不了，但是不用管他，装就完事了)之后选择精简版安装(自定义安装，因为我们只需要cuda) 5.安装完解压cudnn。将解压出来的三个文件夹放到v9文件夹下惯例，添加环境变量 保存退出。再重新进入anaconda promote，运行gpu环境 一般来说到这里就完结了，一下讲一下笔者遇到的玄学时刻 001.numpy版本问题，一开始numpy版本为1.16，出现了numpy 版本不兼容tensorflow的问题 1ImportError: Something is wrong with the numpy installation. While importing we detected an older version of numpy in ['C:\\Users\\Administrator\\Anaconda3\\lib\\site-packages\\numpy']. One method of fixing this is to repeatedly uninstall numpy until none is found, then reinstall this version. 随后笔者更改numpy1.13，代码以下卸载numpy包 1pip uninstall numpy 安装版本为1.13numpy 1pip install numpy=1.13 笔者这里终于成功了，教训深刻。。。可以看出cuda成功运行 这里附上hello world 代码嘻嘻 12345import tensorflow as tfhello = tf.constant("Hello!TensorFlow")sess = tf.Session()print(sess.run(hello)) 002.windows版本tensorflow的兼容性参考 ps.实际上，2017.12的时候，tensorflow 1.4及以下的不支持cuda9.0，且tensorflow1.0版本以上是不支持cuda8.0以下的.tensorflow -gpu1.5以后不支持使用CUDA8.0.cuda8.0对应的cuDNN必须是6.0版的。]]></content>
      <tags>
        <tag>tensorflow</tag>
        <tag>技术</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sekiro之河原田直盛(1)]]></title>
    <url>%2F2019%2F08%2F04%2Fsekiro%2F</url>
    <content type="text"><![CDATA[那么今天打的怪是何方妖孽呢？武士大将河原田直盛，嗯，就是这个看起来挺牛逼的名字，其实说实话是挺牛逼的（你把我逼死了好几十次。。。orz我真的服了）。就是这个小崽子 本着莽就完事的宗旨，上来就被土肥原三刀劈翻在地，出现了上来就秒死的尴尬状况，我当即按下RB，半条命再战，结果也不用猜了 随后n把我逐渐学会了关于死字的书法。我吐了。 欸这就很难受了，随即再战，两段钩锁飞到面前，B键猛冲，就是要砍脸，仙法–X键狂点之术！！很搞笑我被土肥原踹了下去，复活回来就发现土肥原被困在一个小角落 当我熟练使用gay洛的拜年剑法的时候，惨了，土肥原40米大刀一招扫地龙已把我收了。。 随即又是n次 终于我发现可以忍杀掉一条命的时候，又tm的最悲惨的是，人跳下去了，那个红点却不见了。完了，又是被砍死。 途中还有几次忍杀成功的，两刀砍死。。。 终于这回轻装上阵，拿起刀就是往脸上招呼，虽然没有一下子忍杀掉，但土肥原招架不住我犀利的刀法，一条命get。我随即狂按B键迅速拉开身位，熟练地拿起小葫芦灌了一口药。看到血量回升的感觉真的舒服。废话不多说，敌进我退敌疲我打，关键时候乱刀招呼，直接忍杀！ 炫，疯狂地炫]]></content>
      <tags>
        <tag>游戏</tag>
        <tag>之狼</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[当然是线段树模板]]></title>
    <url>%2F2019%2F07%2F20%2F%E5%BD%93%E7%84%B6%E6%98%AF%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[1234567891011121314struct segt &#123; ll *a; ll SUM, MAX, MIN; struct Tree &#123; int l, r; ll sum, lz, max, min, set; void update(ll v) &#123; sum += v * (r - l + 1); lz += v; max += v; min += v; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169 void setval(ll v) &#123; sum = v * (r - l + 1); lz = 0; max = v; min = v; set = v; &#125; &#125; tree[N * 4]; void modify(ll *arr) &#123; a = arr; &#125; void pushup(int x) &#123; tree[x].sum = tree[2 * x].sum + tree[2 * x + 1].sum; tree[x].max = max(tree[2 * x].max, tree[2 * x + 1].max); tree[x].min = min(tree[2 * x].min, tree[2 * x + 1].min); &#125; void pushdown(int x) &#123; if (tree[x].set != -1) &#123; tree[2 * x].setval(tree[x].set); tree[2 * x + 1].setval(tree[x].set); tree[x].set = -1; &#125; if (tree[x].lz != 0) &#123; tree[2 * x].update(tree[x].lz); tree[2 * x + 1].update(tree[x].lz); tree[x].lz = 0; &#125; &#125; // 建树 void build(int x, int l, int r) &#123; tree[x].l = l; tree[x].r = r; tree[x].sum = tree[x].max = tree[x].min = tree[x].lz = 0; tree[x].set = -1; if (l == r) &#123; return; &#125; int mid = (l + r) / 2; build(2 * x, l, mid); build(2 * x + 1, mid + 1, r); pushup(x); &#125; // 将 l-r 范围的数都加上 c void update(int x, int l, int r, ll c) &#123; int L = tree[x].l, R = tree[x].r; int mid = (L + R) / 2; if ((l &lt;= L) &amp;&amp; (r &gt;= R)) &#123; tree[x].update(c); return; &#125; pushdown(x); if (l &lt;= mid) update(2 * x, l, r, c); if (r &gt; mid) update(2 * x + 1, l, r, c); pushup(x); &#125; // 将 l-r 范围的数变成 c， 如果 set 为 -1 表示没有被赋值过 void setval(int x, int l, int r, ll c) &#123; int L = tree[x].l, R = tree[x].r; int mid = (L + R) / 2; if ((l &lt;= L) &amp;&amp; (r &gt;= R)) &#123; tree[x].setval(c); return; &#125; pushdown(x); if (l &lt;= mid) setval(2 * x, l, r, c); if (r &gt; mid) setval(2 * x + 1, l, r, c); pushup(x); &#125; // 查询区间和 ll querySUM(int x, int l, int r) &#123; int L = tree[x].l, R = tree[x].r; int mid = (L + R) / 2; ll res = 0; if ((l &lt;= L) &amp;&amp; (r &gt;= R)) &#123; // 要更新区间包括了该区间 return tree[x].sum; &#125; pushdown(x); if (l &lt;= mid) res += querySUM(2 * x, l, r); if (r &gt; mid) res += querySUM(2 * x + 1, l, r); return res; &#125; // 查询区间最大值 ll queryMAX(int x, int l, int r) &#123; int L = tree[x].l, R = tree[x].r; int mid = (L + R) / 2; ll res = -maxx; if ((l &lt;= L) &amp;&amp; (r &gt;= R)) &#123; // 要更新区间包括了该区间 return tree[x].max; &#125; pushdown(x); if (l &lt;= mid) res = max(res, queryMAX(2 * x, l, r)); if (r &gt; mid) res = max(res, queryMAX(2 * x + 1, l, r)); return res; &#125; // 查询区间最小值 ll queryMIN(int x, int l, int r) &#123; int L = tree[x].l, R = tree[x].r; int mid = (L + R) / 2; ll res = maxx; if ((l &lt;= L) &amp;&amp; (r &gt;= R)) &#123; // 要更新区间包括了该区间 return tree[x].min; &#125; pushdown(x); if (l &lt;= mid) res = min(res, queryMIN(2 * x, l, r)); if (r &gt; mid) res = min(res, queryMIN(2 * x + 1, l, r)); return res; &#125; // 一次性查询区间 SUM，MAX，MIN void query(int x, int l, int r) &#123; int L = tree[x].l, R = tree[x].r; int mid = (L + R) / 2; if ((l &lt;= L) &amp;&amp; (r &gt;= R)) &#123; // 要更新区间包括了该区间 SUM += tree[x].sum; MAX = max(MAX, tree[x].max); MIN = min(MIN, tree[x].min); return; &#125; pushdown(x); if (l &lt;= mid) query(2 * x, l, r); if (r &gt; mid) query(2 * x + 1, l, r); &#125;&#125; tree;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo部署blog]]></title>
    <url>%2F2019%2F07%2F20%2F%E6%97%A5%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[部署了hexo+github的博客 参考了https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html 搭建基于github的个人blog参考了https://www.jianshu.com/p/9f0e90cc32c2 对网站进行优化]]></content>
      <tags>
        <tag>日常</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[还是畅通工程]]></title>
    <url>%2F2019%2F07%2F20%2F%E8%BF%98%E6%98%AF%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[这还是一道基本的并查集模板题 ，init()初始化 ,find()找父亲 ，join()按照rank数组的高度合并 低的到高的上 ，大功告成啦。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;climits&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;map&gt;#define maxx 0x3f3f3f3f#define ll long long#define FAST_IO std::ios::sync_with_stdio(false), std::cin.tie(0), std::cout.tie(0)#define lson l, m, rt &lt;&lt; 1#define rson m + 1, r, rt &lt;&lt; 1 | 1using namespace std;const int maxn = 1e4 + 5;int ran[maxn];int pre[maxn];int n, m;void init()&#123; for (int i = 1; i &lt;= n; i++) &#123; pre[i] = i; ran[i] = 1; &#125;&#125;int find(int x)&#123; if (x == pre[x]) return x; return pre[x] = find(pre[x]);&#125;void join(int x, int y)&#123; int fx = find(x); int fy = find(y); if (fx == fy) return; if (ran[x] &lt; ran[y]) pre[fx] = fy; else &#123; pre[fy] = fx; if (ran[fx] == ran[fy]) ran[fx]++; &#125;&#125;int main()&#123; FAST_IO; while (cin &gt;&gt; n, n) &#123; cin &gt;&gt; m; init(); int a, b; while (m--) &#123; cin &gt;&gt; a &gt;&gt; b; join(a, b); &#125; int ans = 0; for (int i = 1; i &lt;= n; i++) &#123; if (pre[i] == i) ans++; &#125; cout &lt;&lt; ans - 1 &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
</search>
